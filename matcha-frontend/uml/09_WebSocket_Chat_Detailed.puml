@startuml
skinparam DPI 300
title WebSocket Chat Messages - Detailed Flow

participant Client_A
participant "WebSocket Server" as WS
participant Client_B

note over Client_A, Client_B
Send chat message via WebSocket
end note

Client_A -> WS: socket.emit('chatMessage')\n{fromUserId: "A", toUserId: "B",\ncontent: "Hello!", timestamp}
activate WS

WS --> Client_A: socket.emit('serverChatmsg')\n{_id, fromUserId, toUserId, content,\ntimestamp, read: false}\nConfirm message sent
deactivate WS

note over Client_A, Client_B
Server saves message to MongoDB
and broadcasts to recipient
end note

WS -> WS: Validate:\n- Users matched\n- Not blocked\n- Message not empty\n- User B online in wsmap

alt User B is ONLINE
WS -> Client_B: socket.emit('serverChatmsg')\n{_id, fromUserId: "A", toUserId: "B",\ncontent: "Hello!", timestamp,\nread: false}
Client_B --> Client_B: Show incoming message\nAdd to chat view
else User B is OFFLINE
WS -> WS: Queue notification\nfor delivery when B comes online
end

note over Client_A, Client_B
User B receives message and reads it
end note

Client_B -> WS: socket.emit('messageRead')\n{messageId: "_id"}
activate WS

WS --> Client_B: socket.emit('messageRead')\n{messageId: "_id", read: true}
deactivate WS

note over Client_A, Client_B
Server broadcasts read receipt to sender
end note

WS -> Client_A: socket.emit('messageRead')\n{messageId: "_id", read: true}
Client_A --> Client_A: Show double checkmark\nMessage marked as read

note over Client_A, Client_B
Get chat history (HTTP)
end note

Client_A -> WS: HTTP GET /api/user/chat\nAuth: Bearer <tokenA>\nBody: {otherid: "B"}\nQuery: limit=50, skipno=0
activate WS

WS --> Client_A: HTTP 200\n{ChatMessage[]}\nArray of all messages\nwith User B
deactivate WS

note over Client_A, Client_B
Send multiple messages in sequence
end note

Client_A -> WS: socket.emit('chatMessage')\n{fromUserId: "A", toUserId: "B",\ncontent: "Message 1", timestamp1}
activate WS
WS --> Client_A: socket.emit('serverChatmsg')\n{..., _id: "msg1"}
deactivate WS

Client_A -> WS: socket.emit('chatMessage')\n{fromUserId: "A", toUserId: "B",\ncontent: "Message 2", timestamp2}
activate WS
WS --> Client_A: socket.emit('serverChatmsg')\n{..., _id: "msg2"}
deactivate WS

Client_A -> WS: socket.emit('chatMessage')\n{fromUserId: "A", toUserId: "B",\ncontent: "Message 3", timestamp3}
activate WS
WS --> Client_A: socket.emit('serverChatmsg')\n{..., _id: "msg3"}
deactivate WS

WS -> Client_B: socket.emit('serverChatmsg') for msg1
WS -> Client_B: socket.emit('serverChatmsg') for msg2
WS -> Client_B: socket.emit('serverChatmsg') for msg3

note over Client_A, Client_B
Error scenarios
end note

Client_A -> WS: socket.emit('chatMessage')\n{fromUserId: "A", toUserId: "B",\ncontent: ""}
activate WS
WS --> Client_A: socket.emit('error')\n{msg: "Message cannot be empty"}
deactivate WS

Client_A -> WS: socket.emit('chatMessage')\n{fromUserId: "A", toUserId: "nonexistent",\ncontent: "Hi"}
activate WS
WS --> Client_A: socket.emit('error')\n{msg: "User not found"}
deactivate WS

Client_A -> WS: socket.emit('chatMessage')\n{fromUserId: "A", toUserId: "B",\ncontent: "...very long message..."}
activate WS
WS --> Client_A: socket.emit('error')\n{msg: "Message too long"} OR accept
deactivate WS

Client_A -> WS: socket.emit('chatMessage')\nUsers not matched
activate WS
WS --> Client_A: socket.emit('error')\n{msg: "You are not matched with this user"}
deactivate WS

Client_A -> WS: socket.emit('chatMessage')\nBlocked by User B
activate WS
WS --> Client_A: socket.emit('error')\n{msg: "User has blocked you"}
deactivate WS

note over Client_A, Client_B
Get chat history via WebSocket
end note

Client_A -> WS: socket.emit('getChatHistory')\n{otherId: "B", limit: 50, skipno: 0}
activate WS

WS --> Client_A: Emit chat history data\n{ChatMessage[]}\nArray of messages with User B
deactivate WS

Client_A -> WS: socket.emit('getChatHistory')\n{otherId: "B"}\nUsers not matched
activate WS
WS --> Client_A: socket.emit('error')\n{msg: "Users not matched"}
deactivate WS

note over Client_A, Client_B
Connection states during messaging
end note

Client_A -> WS: socket.emit('chatMessage')\nWhile connected
activate WS
WS --> Client_A: socket.emit('serverChatmsg')\nMessage delivered
deactivate WS

Client_A -> WS: Network fails - auto-disconnect
activate WS
WS --> Client_A: socket.emit('disconnect')\n{reason: "transport close"}
deactivate WS

Client_A -> WS: socket.io auto-reconnects
activate WS
WS --> Client_A: socket.emit('connect')\n{socket_id: "new_id"}
deactivate WS

Client_A -> WS: socket.emit('chatMessage')\nAfter reconnection
activate WS
WS --> Client_A: socket.emit('serverChatmsg')\nMessage delivered\nand persisted in MongoDB
deactivate WS

@enduml
